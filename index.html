<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>植物大战僵尸 - 坚果保龄球 (H5版)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header-bar {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .score-box {
            font-size: 24px;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
            border: 2px solid #aeb437;
        }

        .combo-box {
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .combo-box.active { opacity: 1; }

        /* Controls */
        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            pointer-events: auto;
            padding-bottom: 40px;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            user-select: none;
            backdrop-filter: blur(4px);
            transition: transform 0.1s;
        }
        
        .control-btn:active, .control-btn.active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.9);
        }

        /* Modal */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .modal-content {
            background: #4a6c38;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 5px solid #2e282a;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            color: #fff;
            min-width: 280px;
        }

        .modal-title {
            font-size: 32px;
            color: #ffde00;
            margin-bottom: 20px;
            font-weight: bold;
            text-shadow: 2px 2px #000;
        }

        .score-display {
            font-size: 24px;
            margin: 15px 0;
        }

        .btn-gameing {
            background: #9b5800;
            border: 3px solid #643900;
            color: #fff;
            padding: 10px 30px;
            font-size: 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
        }
        .btn-gameing:hover { background: #b86900; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="header-bar">
            <div class="score-box">分数: <span id="scoreVal">0</span></div>
            <div id="comboVal" class="combo-box">连击: 0</div>
        </div>

        <div class="controls-area">
            <div class="control-btn" id="btnLeft">⬅️</div>
            <div class="control-btn" id="btnRight">➡️</div>
        </div>
    </div>

    <div id="gameOverModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">僵尸吃掉了脑子!</div>
            <div class="score-display">最终得分: <span id="finalScore">0</span></div>
            <div class="score-display">最大连击: <span id="finalCombo">0</span></div>
            <button class="btn-gameing" id="restartBtn">重新冒险</button>
        </div>
    </div>

    <div id="startModal" class="modal-overlay" style="display: flex;">
        <div class="modal-content">
            <div class="modal-title">坚果保龄球</div>
            <p>控制坚果左右移动撞击僵尸<br>千万别撞到墙壁！</p>
            <button class="btn-gameing" id="startBtn">开始游戏</button>
        </div>
    </div>

<script>
/**
 * Plants vs Zombies: Nut Bowling (H5 Canvas Edition)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI Elements
const scoreEl = document.getElementById('scoreVal');
const comboEl = document.getElementById('comboVal');
const finalScoreEl = document.getElementById('finalScore');
const finalComboEl = document.getElementById('finalCombo');
const gameOverModal = document.getElementById('gameOverModal');
const startModal = document.getElementById('startModal');

// Game Config
const CONFIG = {
    gravity: 0,
    friction: 0.98,
    moveForce: 30, // Force applied when pressing buttons
    maxSpeed: 800,
    wallFriction: 0.5,
    spawnRate: 1.5, // Seconds
    colors: {
        bg: '#5D9A3B', // Lawn green
        bgAlt: '#538b34', // Striped lawn
        ditch: '#2a2a2a'
    }
};

let width, height;

// Game State
const state = {
    active: false,
    score: 0,
    combo: 0,
    maxCombo: 0,
    lastTime: 0,
    spawnTimer: 0,
    difficultyMultiplier: 1,
    
    // Entities
    player: {
        x: 0,
        y: 0,
        vx: 0,
        radius: 25,
        angle: 0
    },
    
    // Arrays
    zombies: [],
    particles: [],
    
    // Inputs
    keys: { left: false, right: false }
};

// Assets (Procedural drawing for pure H5)
// We will draw standard PvZ style graphics using canvas primitives

// --- Core ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    setupInputs();
    
    // Main Loop
    requestAnimationFrame(gameLoop);
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    if (!state.active) {
        state.player.x = width / 2;
        state.player.y = height - 100;
    }
}

function startGame() {
    state.active = true;
    state.score = 0;
    state.combo = 0;
    state.maxCombo = 0;
    state.difficultyMultiplier = 1;
    state.zombies = [];
    state.particles = [];
    
    state.player.x = width / 2;
    state.player.y = height - 120; // Fixed Y position
    state.player.vx = 0;
    
    state.lastTime = performance.now();
    
    updateScoreUI();
    
    startModal.style.display = 'none';
    gameOverModal.style.display = 'none';
}

function gameOver() {
    state.active = false;
    finalScoreEl.textContent = Math.floor(state.score);
    finalComboEl.textContent = state.maxCombo;
    gameOverModal.style.display = 'flex';
}

// --- Inputs ---

function setupInputs() {
    // Buttons
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    
    const bindBtn = (btn, key) => {
        const hStart = (e) => { e.preventDefault(); state.keys[key] = true; btn.classList.add('active'); };
        const hEnd = (e) => { e.preventDefault(); state.keys[key] = false; btn.classList.remove('active'); };
        btn.addEventListener('touchstart', hStart);
        btn.addEventListener('touchend', hEnd);
        btn.addEventListener('mousedown', hStart);
        btn.addEventListener('mouseup', hEnd);
    };
    
    bindBtn(btnLeft, 'left');
    bindBtn(btnRight, 'right');
    
    // Keyboard
    window.addEventListener('keydown', e => {
        if(e.code === 'ArrowLeft' || e.key === 'a') state.keys.left = true;
        if(e.code === 'ArrowRight' || e.key === 'd') state.keys.right = true;
    });
    
    window.addEventListener('keyup', e => {
        if(e.code === 'ArrowLeft' || e.key === 'a') state.keys.left = false;
        if(e.code === 'ArrowRight' || e.key === 'd') state.keys.right = false;
    });
    
    // Menus
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);
}

// --- Logic ---

function update(dt) {
    if (!state.active) return;
    
    // Difficulty Scaling
    state.difficultyMultiplier += dt * 0.05; // Slowly get harder
    
    // Player Physics
    const p = state.player;
    
    // Input Force
    if (state.keys.left) p.vx -= CONFIG.moveForce;
    if (state.keys.right) p.vx += CONFIG.moveForce;
    
    // Friction
    p.vx *= CONFIG.friction;
    
    // Move
    p.x += p.vx * dt;
    
    // Rotation (Visual)
    p.angle += p.vx * dt * 0.1;
    
    // Wall Checking (The "Ditch")
    const margin = 20; // Ditch width approx
    if (p.x < p.radius + margin || p.x > width - p.radius - margin) {
        // Hit WALL -> Game Over
        gameOver();
        createExplosion(p.x, p.y, '#e74c3c');
        return;
    }
    
    // Spawning Zombies
    state.spawnTimer -= dt;
    if (state.spawnTimer <= 0) {
        spawnZombie();
        state.spawnTimer = CONFIG.spawnRate / (1 + state.difficultyMultiplier * 0.1); 
        if (state.spawnTimer < 0.5) state.spawnTimer = 0.5;
    }
    
    // Update Zombies
    for (let i = state.zombies.length - 1; i >= 0; i--) {
        const z = state.zombies[i];
        
        // Move Down
        z.y += z.speed * dt;
        
        // Wobble
        z.angle = Math.sin(Date.now() / 200) * 0.1;
        
        // Check Offscreen (Player missed them)
        // In Bowling, if you miss a zombie it just goes away? Or do you lose life?
        // Let's say they just disappear for now, maybe reduce score?
        if (z.y > height + 50) {
            state.zombies.splice(i, 1);
            resetCombo();
            continue;
        }
        
        // Collision with Player
        const dx = p.x - z.x;
        const dy = p.y - z.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < p.radius + z.radius) {
            // HIT!
            handleCollision(p, z, i);
        }
    }
    
    // Update Particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const part = state.particles[i];
        part.life -= dt;
        part.x += part.vx * dt;
        part.y += part.vy * dt;
        if (part.life <= 0) state.particles.splice(i, 1);
    }
}

function handleCollision(player, zombie, index) {
    // 1. Physics Bounce
    // Push the player away from the collision normal
    // If player hits right side of zombie, player pushes right.
    // Reference logic: ball.vx -= (zombie.x - ball.x) * factor
    const dx = player.x - zombie.x;
    const impactForce = 300; // Power of the bounce
    
    // Add velocity based on relative position
    player.vx += (dx > 0 ? 1 : -1) * impactForce;
    
    // 2. Gameplay
    state.zombies.splice(index, 1);
    
    // Score
    const pts = 100 * (1 + state.combo * 0.1);
    state.score += pts;
    
    // Combo
    if (Date.now() - state.lastHitTime < 1500) {
        state.combo++;
    } else {
        state.combo = 1;
    }
    state.lastHitTime = Date.now();
    
    if (state.combo > state.maxCombo) state.maxCombo = state.combo;
    if (state.combo > 1) showCombo();
    
    updateScoreUI();
    
    // FX
    createExplosion(zombie.x, zombie.y, '#90EE90'); // Green guts
}

function spawnZombie() {
    const types = [
        { type: 'normal', color: '#689f38', hp: 1, radius: 25, speed: 100 },
        { type: 'cone', color: '#fdd835', hp: 2, radius: 28, speed: 110 }, // Faster
        { type: 'bucket', color: '#757575', hp: 3, radius: 30, speed: 90 }, // Slower, tanky (logic not imp yet)
    ];
    
    const choice = types[Math.floor(Math.random() * types.length)];
    
    // Speed increases with difficulty
    const speed = choice.speed * (1 + state.difficultyMultiplier * 0.1);
    
    state.zombies.push({
        x: Math.random() * (width - 100) + 50,
        y: -50,
        ...choice,
        speed: speed,
        angle: 0
    });
}

function resetCombo() {
    state.combo = 0;
    comboEl.classList.remove('active');
}

function showCombo() {
    comboEl.textContent = `连击 x${state.combo}`;
    comboEl.classList.add('active');
    setTimeout(() => comboEl.classList.remove('active'), 1000);
}

function updateScoreUI() {
    scoreEl.textContent = Math.floor(state.score);
}

function createExplosion(x, y, color) {
    for(let i=0; i<15; i++) {
        state.particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 300,
            vy: (Math.random() - 0.5) * 300,
            life: 0.5 + Math.random() * 0.5,
            color: color,
            size: Math.random() * 5 + 2
        });
    }
}

// --- Rendering ---

function draw() {
    // 1. Background
    // Draw Lawn Stripes
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, width, height);
    
    // Stripes
    ctx.fillStyle = CONFIG.colors.bgAlt;
    const stripeH = 80;
    for (let y = 0; y < height; y += stripeH * 2) {
        ctx.fillRect(0, y, width, stripeH);
    }
    
    // Ditches (Side Walls)
    ctx.fillStyle = CONFIG.colors.ditch;
    const ditchW = 15;
    ctx.fillRect(0, 0, ditchW, height);
    ctx.fillRect(width - ditchW, 0, ditchW, height);

    if (!state.active) return; // Only BG when inactive

    // 2. Zombies
    state.zombies.forEach(z => {
        ctx.save();
        ctx.translate(z.x, z.y);
        ctx.rotate(z.angle);
        
        // Body
        ctx.fillStyle = z.color;
        ctx.beginPath();
        ctx.arc(0, 0, z.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-8, -5, 6, 0, Math.PI*2);
        ctx.arc(8, -5, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-8, -5, 2, 0, Math.PI*2);
        ctx.arc(8, -5, 2, 0, Math.PI*2);
        ctx.fill();

        // Accessories
        if (z.type === 'cone') {
            ctx.fillStyle = '#fdd835'; // Traffic cone orange
            ctx.beginPath();
            ctx.moveTo(-15, -15);
            ctx.lineTo(15, -15);
            ctx.lineTo(0, -45);
            ctx.fill();
        } else if (z.type === 'bucket') {
            ctx.fillStyle = '#9e9e9e'; // Bucket grey
            ctx.fillRect(-15, -35, 30, 25);
        }

        ctx.restore();
    });

    // 3. Player (The Nut)
    const p = state.player;
    ctx.save();
    ctx.translate(p.x, p.y);
    
    // Rolling effect
    ctx.rotate(p.angle * 0.1); 
    
    // Nut Body
    ctx.fillStyle = '#D68910'; // Brown
    ctx.beginPath();
    // Nut shape basically an oval
    ctx.ellipse(0, 0, p.radius, p.radius * 1.1, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#5d4037';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Nut Face
    ctx.fillStyle = '#fff';
    // Eyes
    ctx.beginPath();
    ctx.arc(-8, -5, 8, 0, Math.PI*2);
    ctx.arc(8, -5, 8, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-8, -5, 3, 0, Math.PI*2);
    ctx.arc(8, -5, 3, 0, Math.PI*2);
    ctx.fill();
    
    // Mouth
    ctx.beginPath();
    ctx.arc(0, 10, 5, 0, Math.PI, false);
    ctx.stroke();
    
    ctx.restore();
    
    // 4. Particles
    state.particles.forEach(part => {
        ctx.globalAlpha = part.life;
        ctx.fillStyle = part.color;
        ctx.beginPath();
        ctx.arc(part.x, part.y, part.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });
}

function gameLoop(time) {
    const dt = (time - state.lastTime) / 1000;
    state.lastTime = time;
    
    // Cap dt for stability
    if (dt < 0.1) {
        update(dt);
        draw();
    }
    
    requestAnimationFrame(gameLoop);
}

// Start
init();

</script>
</body>
</html>